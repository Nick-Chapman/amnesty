
#include <assert.h>
#include <stdio.h>
#include "rt.h"

#include "SDL.h"

u8 reg_RegX;
u8 reg_RegY;
u8 reg_RegZ;
u8 reg_RegN;
u8 reg_RegP;
u8 reg_RegScanX;
u8 reg_RegScanY;

const int scale = 4;
const int width = 256;
const int height = 240;

SDL_Renderer* the_renderer = 0;

SDL_Window* createWindow() {
  int x = 10000; //SDL_WINDOWPOS_CENTERED;
  int y = 0; //SDL_WINDOWPOS_CENTERED;
  int w = width * scale;
  int h = height * scale;
  int flags = 0;
  return SDL_CreateWindow ("amnesty", x, y, w, h, flags);
}

int main() {
  printf("main..\n");
  SDL_Window* window = createWindow();
  int rflags = SDL_RENDERER_ACCELERATED; //| SDL_RENDERER_PRESENTVSYNC;
  the_renderer = SDL_CreateRenderer(window, -1, rflags);
  for(int i = 0;; i++) {
    printf("loop: %d\n",i);
    ppu();
    SDL_RenderPresent(the_renderer);
  }
  SDL_DestroyRenderer(the_renderer);
  SDL_DestroyWindow(window);
  printf("main..done\n");
}

u1 is_pressed(Key key) {
  //assert(0);
  return 0;
}

u8 read_mem(u16 addr) {
  if (addr < 0x2000) {
    u8 b = chr1[addr];
    //printf("readMem: %04x --> %02x\n",addr,b);
    return b;
  }
  assert(0);
}
u16 hilo(u8 hi,u8 lo) {
  return (hi << 8) | lo;
}
u1 testbit(u8 v,u8 n) {
  //printf("testbit (%d,%d)\n",v,n);
  assert(0 <= n && n < 8);
  return v & (1<<n);
}

typedef struct { u8 r; u8 g; u8 b; } rgb;

rgb raw[] =
{
 {0x66, 0x66, 0x66}, {0x00, 0x2A, 0x88}, {0x14, 0x12, 0xA7}, {0x3B, 0x00, 0xA4},
 {0x5C, 0x00, 0x7E}, {0x6E, 0x00, 0x40}, {0x6C, 0x06, 0x00}, {0x56, 0x1D, 0x00},
 {0x33, 0x35, 0x00}, {0x0B, 0x48, 0x00}, {0x00, 0x52, 0x00}, {0x00, 0x4F, 0x08},
 {0x00, 0x40, 0x4D}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
 {0xAD, 0xAD, 0xAD}, {0x15, 0x5F, 0xD9}, {0x42, 0x40, 0xFF}, {0x75, 0x27, 0xFE},
 {0xA0, 0x1A, 0xCC}, {0xB7, 0x1E, 0x7B}, {0xB5, 0x31, 0x20}, {0x99, 0x4E, 0x00},
 {0x6B, 0x6D, 0x00}, {0x38, 0x87, 0x00}, {0x0C, 0x93, 0x00}, {0x00, 0x8F, 0x32},
 {0x00, 0x7C, 0x8D}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
 {0xFF, 0xFE, 0xFF}, {0x64, 0xB0, 0xFF}, {0x92, 0x90, 0xFF}, {0xC6, 0x76, 0xFF},
 {0xF3, 0x6A, 0xFF}, {0xFE, 0x6E, 0xCC}, {0xFE, 0x81, 0x70}, {0xEA, 0x9E, 0x22},
 {0xBC, 0xBE, 0x00}, {0x88, 0xD8, 0x00}, {0x5C, 0xE4, 0x30}, {0x45, 0xE0, 0x82},
 {0x48, 0xCD, 0xDE}, {0x4F, 0x4F, 0x4F}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
 {0xFF, 0xFE, 0xFF}, {0xC0, 0xDF, 0xFF}, {0xD3, 0xD2, 0xFF}, {0xE8, 0xC8, 0xFF},
 {0xFB, 0xC2, 0xFF}, {0xFE, 0xC4, 0xEA}, {0xFE, 0xCC, 0xC5}, {0xF7, 0xD8, 0xA5},
 {0xE4, 0xE5, 0x94}, {0xCF, 0xEF, 0x96}, {0xBD, 0xF4, 0xAB}, {0xB3, 0xF3, 0xCC},
 {0xB5, 0xEB, 0xF2}, {0xB8, 0xB8, 0xB8}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}
};

void emitPixel(u8 x,u8 y,u8 col6) {
  //printf("emitPixel (%d,%d) %d\n",x,y,col6);
  assert (0 <= col6 && col6 <= 63);
  rgb col = raw[col6];
  SDL_SetRenderDrawColor(the_renderer, col.r, col.g, col.b, 255);
  SDL_Rect rect = { x * scale, y * scale, scale, scale };
  SDL_RenderFillRect(the_renderer, &rect);
}
